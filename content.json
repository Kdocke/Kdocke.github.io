{"meta":{"title":"Kdocke","subtitle":"","description":"","author":"Kdocke","url":"http://yoursite.com"},"pages":[{"title":"关于博主","date":"2020-07-13T03:44:42.823Z","updated":"2020-07-13T03:44:42.823Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我生命在于折腾 联系我博主 Github 地址：https://github.com/Kdocke 联系邮箱：kdocked@163.com"}],"posts":[{"title":"WebStorm 2020 安装教程","slug":"WebStorm2020安装教程","date":"2020-07-19T11:14:46.000Z","updated":"2020-07-19T11:28:24.550Z","comments":true,"path":"2020/07/19/WebStorm2020安装教程/","link":"","permalink":"http://yoursite.com/2020/07/19/WebStorm2020%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、下载官方网站： WebStorm-2020.1.3 注册插件： 链接：https://pan.baidu.com/s/1p2wInphLxzxM8DoHfA1OMA 提取码：zhlz 二、安装1.双击 WebStorm-2020.1.3.exe 安装文件，跳出欢迎界面，Next 2.选择安装位置，建议非 C 盘，Next 3.直接 Next 4.Install 5.运行 WebStorm 三、注册1.打开 WebStorm，不导入设置 2.选择主题，Next 3.Start using WebStorm 4.选择免费试用30天 5.选择 Configure 下的 Plugins，选择从硬盘安装插件 6.选择下载的插件 jetbrains-agent.jar，重启 WebStorm 7.激活方式为 Activation code,点击为 WebStorm 安装，确定重启 WebStorm,即可激活成功","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"http://yoursite.com/tags/WebStorm/"},{"name":"开发工具","slug":"开发工具","permalink":"http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}]},{"title":"Spark 相关知识点总结","slug":"Spark相关知识点总结","date":"2020-07-18T11:53:58.000Z","updated":"2020-07-18T11:59:18.221Z","comments":true,"path":"2020/07/18/Spark相关知识点总结/","link":"","permalink":"http://yoursite.com/2020/07/18/Spark%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.Transformation 和 Action 的区别：Transformation 返回值还是一个 RDD。对一个 RDD 进行计算后，变换成另外一个 RDD，然后这个 RDD 又可以进行另外一次转换。且 Transformation 采用的是懒加载策略，即如果只是将 transformation 提交是不会执行计算的，计算只有在 action 被提交的时候才被触发。 Action 返回值不是一个 RDD。它要么是一个 Scala 的普通集合，要么是一个值，要么是空，最终或返回到 Driver 程序，或把 RDD 写入到文件系统中。即只有当程序遇到 action 算子的时候，才会触发一个 job，真正提交运算到集群中。 2. Spark 的特点快速、简洁易用、通用、多种运行模式 3. SparkContext 的特点 Spark 的程序编写时基于 SparkContext 的，具体包括两方面:Spark 编程的核心基础 –RDD，是由 SparkContext 来最初创建（第一个 RDD 一定是由 SparkContext 来创建的）；Spark 程序的调度优化优势基于 SparkContext； Spark 程序的注册是通过 SparkContext 实例化的时候产生的对象来完成的（其实是 SchedulerBackend 来注册程序） Spark 程序运行的时候通过 Cluster Manager 获取具体的计算资源，计算资源的获取也是通过 SparkContext 产生的对象来申请的(其实是 SchedulerBackend 来获取计算资源的）; sparkContext 崩溃或者结束的时候整个 Spark 程序也就结束。 4. SparkSQL 的特点 支持多种数据源：Hive、RDD、Parquet、JSON、JDBC等。 多种性能优化技术：in-memory columnar storage、byte-code generation、cost model动态评估等。 组件扩展性：对于SQL的语法解析器、分析器以及优化器，用户都可以自己重新开发，并且动态扩展。 5. 窄依赖宽依赖窄依赖：英文全名：NarrowDpendency，简单的说，就是一个RDD对他的父RDD只有简单的一对一依赖关系。就是说，RDD的每个partition，仅仅依赖父RDD的其中的一个partition。父RDD和子RDD之间的关系比较单一，是一对一的。 宽依赖：英文全名，ShuffleDependency，本质如其名，就是shuffle，也就是说每个父RDD中的parttion中的数据，都可能会传输一部分，到下一个RDD的每一个partition中，此时就会出现，父RDD和子RDD的partion之间具有交互错综复杂的关系，那么这种情况，就叫做两个RDD之间的宽依赖，同时注意到的是，他们之间发生的操作叫做Sheufle。 6. 共享变量Spark一个非常重要的特性就是共享变量。 默认情况下，如果在一个算子的函数中使用到了某个外部的变量，那么这个变量的值会被拷贝到每个task中。此时每个 task只能操作自己的那份变量副本。如果多个task想要共享某个变量，那么这种方式是做不到的。 Spark为此提供了两种共享变量，一种是 Broadcast Variable（广播变量），另一种是 Accumulator（累加变 量）。Broadcast Variable 会将使用到的变量，仅仅为每个节点拷贝一份，更大的用处是优化性能，减少网络传输 以及内存消耗。Accumulator 则可以让多个 task 共同操作一份变量，主要可以进行累加操作 7. RDD 持久化策略常用的持久化策略： MEMORY_ONLY：以非序列化的java对象的方式持久化到JVM的内存中；如果内存不足，那么那些没有持久化的partition就会在下一次需要使用的时候被重新计算 MEMORY_AND_DISK：同上，但是某些partitions无法存储在内存中时，会持久化到磁盘，下次使用这些partitions是需要从磁盘读取 MEMORY_ONLY_SER：同MEMORY_ONLY，但是会使用Java序列化方式，将Java对象序列化进行持久化，可以减少内存开销，但是需要进行反序列化，因袭会加大cpu的开销 MEMORY_AND_DISK_SER：同上 DISK_ONLY：以非序列化的java对象的方式持久化，完全存储在磁盘上 MEMORY_ONLY_2，DISK_ONLY_2：如果尾部加了2的持久化级别，表示会将持久化数据复用一份，保保存到其他的节点中，从而在数据丢失时，不需要再次计算，只需要使用备份数据即可 如何选择RDD的持久化策略： 优先使用MEMORY_ONLY 使用MEMORY_ONLY，内存不够，使用MEMORY_ONLY_SER 数据比较重要，时间紧，建议使用带2的后缀的持久化策略 能不使用DISK相关的策略就不使用（视情况而定） 8. Spark 常用术语解释 Application： Appliction的概念和 hadoopMR 中的有些相似，都是指用户编写的 Spark 应用程序，其中包括一个 Driver 功能的代码和分布在集群中多个节点上运行的 Executor 代码。 Driver 使用 Driver 这一个概念的分布式框架很多，比如 hive 等，Spark 中的 Driver 即运行上述 Application的 main 函数并创建 SparkContext，创建 SparkContext 的目的是为了准备 Spark 应用程序的运行环境，在Spark 中有 SparkContext 负责与 ClusterManager 通信，进行资源申请、任务的分配和监控等，当 Executor部分运行完毕后， Driver 同时负责将 SparkContext 关闭，通常用 SparkContext 代表 Driver。 Executor： 某个 Application 运行在 worker 节点上的一个进程， 该进程负责运行某些 Task， 并且负责将数据存到内存或磁盘上，每个 Application 都有各自独立的一批 Executor， 在 Spark on Yarn 模式下，其进程名称为 CoarseGrainedExecutor Backend，类似与 hadoop MR 中的 YarnChild。一个CoarseGrainedExecutor Backend 有且仅有一个 Executor 对象， 负责将 Task 包装成 taskRunner, 并从线程池中抽取一个空闲线程运行 Task， 这个每一 个 CoarseGrainedExecutor Backend 能并行运行 Task 的数量取决与分配给它的 cpu 个数。 Cluter Manager：指的是在集群上获取资源的外部服务。目前有三种类型 Standalon : spark原生的资源管 理，由Master负责资源的分配，可以在EC2上运行 Apache Mesos:与hadoop MR兼容性良好的一种资源调度框 架。 Hadoop Yarn: 主要是指Yarn中的ResourceManager。 Worker: Worker 集群中任何可以运行 Application 代码的节点，类似与 Yarn 中的 NodeManager 节点， 在Standalone 模式 中指的是通过 slave 文件配置的 Worker 节点，在 Spark on Yarn 模式下就是 NoteManager 节点。 Task: 被送到某个 Executor上 的工作单元，但 hadoopMR 中的 MapTask 和 ReduceTask 概念一样，是运行 Application 的基本单位，多个 Task 组成一个 Stage，而 Task 的调度和管理等是由 TaskScheduler 负责。 Job： 包含多个 Task 组成的并行计算，往往由 Spark Action 触发生成， 一个 Application 中往往会产生多个Job。 Stage： 每个 Job 会被拆分成多组 Task， 作为一个 TaskSet， 其名称为 Stage，Stage 的划分和调度是有 DAGScheduler 来负责的，Stage 有非最终的 Stage（Shuﬄe Map Stage）和最终的 Stage（Result Stage）两种， Stage 的边界就是发生 shuﬄe 的地方。 RDD： Spark 的基本计算单元，可以通过一系列算子进行计算（主要由 Transformation 和 Action 操作），同时 RDD 是 Spark 最核心的东西，他表示已被分区、被序列化的、不可变的、有容错的并且能够被并行操作的数据集合。其 存储级别可以是内存，也可以是磁盘，可通过 spark.storage.StoragerLevel 属性来配置。 共享变量： 在 Spark Application 运行期间，可能需要一些共享变量， 提供给 Task 或 Driver 使用，Spark 提供了两种共享变量，一个可以缓存到各个节点的广播变量；另一种是只支持加法操作，可以实现求和的累加变量。 宽依赖： 或称为为 ShuﬄeDependency，与 Hadoop MR 的 Shuﬄe 的数据依赖相似，宽依赖需要计算所有父 RDD 对应分区的数据，然后在节点之间进行 shuﬄe。 窄依赖： 或称为 NarrowDependency， 某个具体的 RDD，其分区 partition a 最多子 Rdd 中一个分区partition b依 赖，此种情况只有 Map 任务， 是不需要发送 shuﬄe 过程的， 窄依赖又分为 1:1 和 N:1 两种。 DAGScheduler： 根据 Job 构建基于 Stage 的 DAG，并提交 Stage 给 TASkScheduler。 其划分 Stage 的依据是 RDD 之间的依赖的关系。 TASKSedulter： 将 TaskSet 提交给 worker 运行，每个 Executor 运行什么 Task 就是在此处分配的。 参考：https://www.cnblogs.com/superhedantou/p/5699201.html","categories":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"http://yoursite.com/tags/Spark/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}]},{"title":"Spark 学习笔记之 RDD","slug":"Spark学习笔记之RDD","date":"2020-07-17T15:45:37.000Z","updated":"2020-07-17T15:56:03.025Z","comments":true,"path":"2020/07/17/Spark学习笔记之RDD/","link":"","permalink":"http://yoursite.com/2020/07/17/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BRDD/","excerpt":"","text":"Spark RDD1. 简述RDD 是一个基本的抽象，操作RDD就像操作一个本地集合一样，降低了编程的复杂度。 RDD 里面记录的是描述信息（从哪里读数据、以后对数据如何计算）、RDD 的方法分为两类 Transformation、Action（生成 Task，并发送到 Excutor 中执行） RDD的特点： 1、一系列分区 2、每一个输入切片会有一个函数作用在上面 3、RDD 和 RDD 之间存在依赖关系（子 RDD 是 父 RDD 调用什么方法，传入哪些函数得到的） 4、（可选）RDD 中如果存储的是 KV，shuffle 时会有一个分区器，默认是 hash partitioner 5、（可选）如果是读取 HDFS 中的数据，那么会有一个最优位置 一个分区对应一个 Task（在同一个 Stage）, 一个分区对应的 Task 只能在一台机器里面（Executor），一台机器上可以有多个分区对应的 Task。 2. RDD 常用算子123456# scala 转 RDD 并行计算val rdd1 = sc.parallelize(List(5,6,4,7,3,8,2,9,1,10))val rdd2 = sc.parallelize(List(5,6,4,7,3,8,2,9,1,10)).map(_*2).sortBy(x=&gt;x,true)val rdd3 = rdd2.filter(_&gt;10)val rdd2 = sc.parallelize(List(5,6,4,7,3,8,2,9,1,10)).map(_*2).sortBy(x=&gt;x+\"\",true)val rdd2 = sc.parallelize(List(5,6,4,7,3,8,2,9,1,10)).map(_*2).sortBy(x=&gt;x.toString,true) 12val rdd4 = sc.parallelize(Array(\"a b c\", \"d e f\", \"h i j\"))rdd4.flatMap(_.split(' ')).collect 12val rdd5 = sc.parallelize(List(List(\"a b c\", \"a b b\"),List(\"e f g\", \"a f g\"), List(\"h i j\", \"a a b\")))rdd5.flatMap(_.flatMap(_.split(\" \"))).collect 12345# union求并集，注意类型要一致val rdd6 = sc.parallelize(List(5,6,4,7))val rdd7 = sc.parallelize(List(1,2,3,4))val rdd8 = rdd6.union(rdd7)rdd8.distinct.sortBy(x=&gt;x).collect 12# intersection求交集val rdd9 = rdd6.intersection(rdd7) 12345678910111213141516171819val rdd1 = sc.parallelize(List((\"tom\", 1), (\"jerry\", 2), (\"kitty\", 3)))val rdd2 = sc.parallelize(List((\"jerry\", 9), (\"tom\", 8), (\"shuke\", 7), (\"tom\", 2)))#join(连接)val rdd3 = rdd1.join(rdd2)val rdd3 = rdd1.leftOuterJoin(rdd2)val rdd3 = rdd1.rightOuterJoin(rdd2)# groupByKey（不会局部聚合）val rdd3 = rdd1 union rdd2rdd3.groupByKey//(tom,CompactBuffer(1, 8, 2))rdd3.groupByKey.map(x=&gt;(x._1,x._2.sum))groupByKey.mapValues(_.sum).collectArray((tom,CompactBuffer(1, 8, 2)), (jerry,CompactBuffer(9, 2)), (shuke,CompactBuffer(7)), (kitty,CompactBuffer(3)))# WordCountsc.textFile(\"/root/words.txt\").flatMap(x=&gt;x.split(\" \")).map((_,1)).reduceByKey(_+_).sortBy(_._2,false).collectsc.textFile(\"/root/words.txt\").flatMap(x=&gt;x.split(\" \")).map((_,1)).groupByKey.map(t=&gt;(t._1, t._2.sum)).collect 12345# cogroupval rdd1 = sc.parallelize(List((\"tom\", 1), (\"tom\", 2), (\"jerry\", 3), (\"kitty\", 2)))val rdd2 = sc.parallelize(List((\"jerry\", 2), (\"tom\", 1), (\"shuke\", 2)))val rdd3 = rdd1.cogroup(rdd2)val rdd4 = rdd3.map(t=&gt;(t._1, t._2._1.sum + t._2._2.sum)) 1234# cartesian笛卡尔积val rdd1 = sc.parallelize(List(\"tom\", \"jerry\"))val rdd2 = sc.parallelize(List(\"tom\", \"kitty\", \"shuke\"))val rdd3 = rdd1.cartesian(rdd2) 12345678910111213141516171819202122232425# spark actionval rdd1 = sc.parallelize(List(1,2,3,4,5), 2)# collectrdd1.collect# reduceval r = rdd1.reduce(_+_)# reduceByKey（局部聚合再全局聚合）# countrdd1.count# toprdd1.top(2)# takerdd1.take(2)# first(similer to take(1))rdd1.first# takeOrderedrdd1.takeOrdered(3) 3. 高级算子mapPartitionsWithIndex: 一次拿出一个分区（分区在并没有数据，而是记录要读取哪些数据，真正生成的 Task 才会读取多条数据），并且可以将分区的编号取出来 功能：取分区中对应的数据时，还可以将分区的编号取出来，这样就可以知道数据是属于哪个分区的（哪个分区对应的Task的数据） 123456789101112val rdd = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2)# 自定义函数(将对应分区中的数据取出来，并且带上分区编号)val func = (index: Int, it: Iterator[Int]) =&gt; &#123; it.map(e =&gt; s\"part: $index, ele: $e\")&#125;val rdd2 = rdd.mapPartitionsWithIndex(func)rdd2.collect# 结果:res0: Array[String] = Array(part: 0, ele: 1, part: 0, ele: 2, part: 0, ele: 3, part: 0, ele: 4, part: 1, ele: 5, part: 1, ele: 6, part: 1, ele: 7, part: 1, ele: 8, part: 1, ele: 9) aggregate: 聚合（局部聚合再全局聚合） 12345678910111213141516171819202122val rdd = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2)val rdd2 = sc.parallelize(List(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"), 2)val rdd3 = sc.parallelize(List(\"12\",\"23\",\"345\",\"4567\"), 2)val rdd4 = sc.parallelize(List(\"12\",\"23\",\"345\",\"\"), 2)# 1rdd.aggregate(0)(_+_, _+_)# 2rdd.aggregate(0)(math.max(_,_), _+_)# 3rdd2.aggregate(\"\")(_+_, _+_)# 4rdd3.aggregate(\"\")((x, y) =&gt; math.max(x.length, y.length).toString, (x,y) =&gt; x+y)# 5rdd4.aggregate(\"\")((x,y) =&gt; math.min(x.length, y.length).toString, (x,y) =&gt; x+y)# 结果:1: res1: Int = 452: res2: Int = 133: res3: String = abcdef or res4: String = defabc4: res5: String = 24 or res13: String = 425: res14: String = 01 or res16: String = 10 aggregateByKey: 分组聚合 1234567val pairRDD = sc.parallelize(List( (\"cat\",2), (\"cat\", 5), (\"mouse\", 4),(\"cat\", 12), (\"dog\", 12), (\"mouse\", 2)), 2)# 1pairRDD.aggregateByKey(0)(_+_, _+_).collect# 结果:1: res17: Array[(String, Int)] = Array((dog,12), (cat,19), (mouse,6)) collectAsMap: 123456val rdd = sc.parallelize(List((\"a\", 1), (\"b\", 2)))rdd.collectAsMap# 结果:res19: scala.collection.Map[String,Int] = Map(b -&gt; 2, a -&gt; 1) countByKey: 12345678910val rdd1 = sc.parallelize(List((\"a\", 1), (\"b\", 2), (\"b\", 2), (\"c\", 2), (\"c\", 1)))# 1rdd1.countByKey# 2rdd1.countByValue# 结果：1： res0: scala.collection.Map[String,Long] = Map(a -&gt; 1, b -&gt; 2, c -&gt; 2)2： res1: scala.collection.Map[(String, Int),Long] = Map((a,1) -&gt; 1, (b,2) -&gt; 2, (c,2) -&gt; 1, (c,1) -&gt; 1) filterByRange： 123456val rdd1 = sc.parallelize(List((\"e\", 5), (\"c\", 3), (\"d\", 4), (\"c\", 2), (\"a\", 1)))rdd1.filterByRange(\"b\", \"d\").collect# 结果：res2: Array[(String, Int)] = Array((c,3), (d,4), (c,2)) flatMapValues： 123456val rdd3 = sc.parallelize(List((\"a\", \"1 2\"), (\"b\", \"3 4\")))rdd3.flatMapValues(_.split(\" \")).collect# 结果：res5: Array[(String, String)] = Array((a,1), (a,2), (b,3), (b,4)) foldByKey: 12345678val rdd1 = sc.parallelize(List(\"dog\", \"wolf\", \"cat\", \"bear\"), 2)val rdd2 = rdd1.map(x =&gt; (x.length, x))val rdd3 = rdd2.foldByKey(\"\")(_+_)rdd3.collect# 结果：res8: Array[(Int, String)] = Array((4,bearwolf), (3,dogcat)) foreach 和 foreachPartition： 1234val rdd = sc.parallelize(List(1,2,3,4,5,6,7,8), 2)rdd.foreach(x =&gt; println(x*100))rdd.foreachPartition(it =&gt; it.foreach(x =&gt; println(x*10000))) 总结： Transformation Action aggregateByKey collect reduceByKey aggregate filter saveAsTextFile flatMap foreach map foreachPartition mapPartition mapPartitionWithIndex 4. WordCount 的执行流程6 个 RDD 2 个 Stage 2 类 Task 4 个 Task（2个分区） 5. Cache什么时候进行 cache: 要求计算速度快 集群的资源足够大 重要：cache 的数据会多次的触发 Action 先进行过滤，然后将缩小范围的数据再 cache 到内存 cache 实际调用的是 persist( ) 方法 123456789101112val NONE = new StorageLevel(false, false, false, false) val DISK_ONLY = new StorageLevel(true, false, false, false) val DISK_ONLY_2 = new StorageLevel(true, false, false, false, 2) val MEMORY_ONLY = new StorageLevel(false, true, false, true) val MEMORY_ONLY_2 = new StorageLevel(false, true, false, true, 2) val MEMORY_ONLY_SER = new StorageLevel(false, true, false, false) val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, false, 2) val MEMORY_AND_DISK = new StorageLevel(true, true, false, true) val MEMORY_AND_DISK_2 = new StorageLevel(true, true, false, true, 2) val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false, false) val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, false, 2) val OFF_HEAP = new StorageLevel(true, true, true, false, 1) 12345678val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)// 第一个参数，放到磁盘// 第二个参数，放到内存// 第三个参数，使不使用 OFF_HEAP// 第四个参数，内存中的数据，以java对象的方式保存OFF_HEAP:堆外内存 （Tachyon，分布式内存存储系统）Alluxio - Open Source Memory Speed Virtual Distributed Storage 使用： 12345678# 将数据缓存至内存val cached: RDD[((String, String), Int)] = reduced.cache()# 使用缓存的数据进行计算val filtered: RDD[((String, String), Int)] = cached.filter(_._1._1 == sb)# 释放缓存cached.unpersist(true) 6. CheckPoint什么时候做 checkpoint: 迭代计算，要求保证数据安全 对速度要求不高（跟cache到内存进行对比） 将中间结果保存到hdfs 设置checkpoint目录（分布式文件系统的目录hdfs目录）经过复杂进行，得到中间结果将中间结果checkpoint到指定的hdfs目录后续的计算，就可以使用前面ck的数据了 使用： 123456789101112# 设置还原点目录（分布式文件系统）sc.setCheckpointDir(\"hdfs://NameNode:9000/test\")# 读数据val lines = sc.textFile(\"hdfs://NameNode/data\")val filtered = lines.filter(_.contains(\"javaee\"))# 设置 checkpoint 的数据，此时不会写数据，只会标记filtered.checkpoint# 此时会 checkpoint 数据filter.count","categories":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Spark","slug":"Spark","permalink":"http://yoursite.com/tags/Spark/"},{"name":"RDD","slug":"RDD","permalink":"http://yoursite.com/tags/RDD/"}],"keywords":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}]},{"title":"SlideToShutDown 下滑关机任务栏设置","slug":"SlideToShutDown下滑关机任务栏设置","date":"2020-07-16T11:55:42.000Z","updated":"2020-07-16T12:03:10.596Z","comments":true,"path":"2020/07/16/SlideToShutDown下滑关机任务栏设置/","link":"","permalink":"http://yoursite.com/2020/07/16/SlideToShutDown%E4%B8%8B%E6%BB%91%E5%85%B3%E6%9C%BA%E4%BB%BB%E5%8A%A1%E6%A0%8F%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"使用 SlideToShutDown 可以实现下滑关机： 1. 找到 SlideToShutDown.exe(C:\\Windows\\System32)2. 右键，固定到任务栏3. 右键任务栏图标 –&gt; 右键 SlideToShutDown –&gt; 属性 –&gt; 更改图标 –&gt; 选择图标","categories":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"SlideToShutDown","slug":"SlideToShutDown","permalink":"http://yoursite.com/tags/SlideToShutDown/"}],"keywords":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}]},{"title":"常见博客框架","slug":"常见博客框架","date":"2020-07-14T11:57:02.000Z","updated":"2020-07-18T12:35:29.511Z","comments":true,"path":"2020/07/14/常见博客框架/","link":"","permalink":"http://yoursite.com/2020/07/14/%E5%B8%B8%E8%A7%81%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/","excerpt":"","text":"一、动态博客1、自建前端（Thymeleaf…），后端（SpringBoot、MySQL……），登录注册 优点：更加灵活，易于管理 缺点：需要懂前前后端开发技术，且需要个人服务器 2、wordpress网址：worepress 优点：开源，方便 二、静态博客1、hexo网址：hexo 优点，快速，简洁，高效，一键部署，可以部署到 GitHub、Gitte 等 搭建教程: 使用 Hexo 搭建个人博客 2、jekyllrb网址：jekyllrb 优点：类似于hexo 3、hugo网址：hugo 优点：go语言实现，安装简单，皮肤酷炫 4、vuepress网址：vuepress 优点：新出，快速 5、solo网址：solo jdk支持 优点：新出 三、参考 CodeSheep程序羊 Youtube 视频教程","categories":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"博客框架","slug":"博客框架","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/"}],"keywords":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/categories/%E8%AE%B0%E5%BD%95/"}]},{"title":"院中小鸟","slug":"院中小鸟","date":"2020-07-13T11:40:41.000Z","updated":"2020-07-13T12:03:30.840Z","comments":true,"path":"2020/07/13/院中小鸟/","link":"","permalink":"http://yoursite.com/2020/07/13/%E9%99%A2%E4%B8%AD%E5%B0%8F%E9%B8%9F/","excerpt":"","text":"某日，于院中杏树上偶现一巢，不觉惊喜万分，其巢隐于伸展在屋檐下的枝杈间，上圆下窄，高不过十数厘米，外形不甚精美，内却有蛋三枚，挨挤在枯草铺就的小巢内，安静祥和。 鸟妈妈有时白天并不在巢穴内，我便得以在闲暇之时近距离接触这未知的生命。但到得晚上，鸟妈妈却总是陪伴在孩子的身边，其时正值盛夏，夜晚的空气也更加的温热，鸟妈妈卧于层层杏叶间的巢内，期待着孩子的出世。她非常敏感，初时只要在树边经过，她都会扑棱棱飞走；之后或是慢慢相熟，她才不至我一靠近便惊走，甚至会与我对视一番。她在睡觉时往往会将头藏在翅膀里，待我靠近后便立刻警觉过来，睁开圆圆亮亮的黑眼睛望向我。 过得数日，便又增加了一枚小家伙， 看着它们斑斓的色彩与倚靠在一起的样子，内心多了一丝分外的期待，期待它们破壳而出的时刻，期待它们飞翔于空的姿态… 就在这每日的盼望中，日子一天天过去，我原以为巢内的生命会在我的期待中一点点长大，一点点羽翼渐丰，一点点飞向天空，迎来新的人生。然则… 某日，天有不测，飞来横祸，一长尾恶禽盯上了巢穴内懵然无知的生命，其盘踞在巢穴上方，一口口吞下这一颗颗沉睡的生命。待吾发现之时已为时晚矣，巢内空空如也，其亦早已心满意足的展翅离开，我心中顿时悔恨万分，深感没有担负好自身的责任。 我无法可想当时鸟妈妈的心情，或许她彼时正在觅食，不知道家中已遭强盗的洗劫；或许她就在不远处看着恶贼的侵略，但却无可奈何，她幼小的身体显然不足以抵抗。 我在树边等待良久，期待鸟妈妈的飞来，期待她能重新振作，也期待她能重建家园，然而没有，她永远的离开了，再不曾归来。 想必于其而言失去幼子的孤巢亦是一片伤心地，既家不为家，又何必再回。 惟余这失落的巢穴，与空中无依的灵魂。","categories":[{"name":"散文","slug":"散文","permalink":"http://yoursite.com/categories/%E6%95%A3%E6%96%87/"}],"tags":[{"name":"小鸟","slug":"小鸟","permalink":"http://yoursite.com/tags/%E5%B0%8F%E9%B8%9F/"},{"name":"有感","slug":"有感","permalink":"http://yoursite.com/tags/%E6%9C%89%E6%84%9F/"}],"keywords":[{"name":"散文","slug":"散文","permalink":"http://yoursite.com/categories/%E6%95%A3%E6%96%87/"}]},{"title":"Snippet 博客主题配置","slug":"Snippet博客主题配置","date":"2020-06-22T07:30:30.000Z","updated":"2020-07-15T10:25:07.936Z","comments":true,"path":"2020/06/22/Snippet博客主题配置/","link":"","permalink":"http://yoursite.com/2020/06/22/Snippet%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一、下载主题Git 方式：进入 Hexo 博客所在主目录，执行： 1git clone git:&#x2F;&#x2F;github.com&#x2F;shenliyang&#x2F;hexo-theme-snippet.git themes&#x2F;hexo-theme-snippet 二、安装主题插件因为 hexo-theme-snippet 使用了 ejs 模版引擎 、 Less CSS预编译语言以及在官方插件的基础上 进行功能的开发，以下为必装插件： 123npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S或cnpm install --save hexo-renderer-ejs hexo-renderer-less hexo-deployer-git 三、测试1.修改 hexo-theme-snippet 为 snippet，然后更改站点配置文件的theme配置为snippet 2.然后执行下述命令，再访问浏览器，即可看到主题已经更换成功。 123hexo clean #清空生成的静态文件hexo g #生成新的静态文件hexo s #开启本地访问 3.将博客推到 github, hexo d 四、菜单配置1.修改页面菜单（分类）名称修改博客主题目录下 _config.yml 文件中的 menu 项为以下内容： 1234567891011121314151617## menumenu:- page: 主页 url: &#x2F; icon:- page: 教程 url: &#x2F;categories&#x2F;教程&#x2F; icon:- page: 记录 url: &#x2F;categories&#x2F;记录&#x2F; icon:- page: 散文 url: &#x2F;categories&#x2F;散文&#x2F; icon:- page: 时间轴 url: &#x2F;archives&#x2F; icon: 若要添加新的菜单（分类），只需按照上述格式添加： 123- page: 分享 url: &#x2F;categories&#x2F;分享&#x2F; icon: 2.修改新建文章模板修改博客目录下 scaffolds 中的 post.md 内容为以下： 12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:comments: falseimg:--- 3.新建文章为教程分类下新建一篇 Node.js 安装教程 的测试文章 hexo n “Node.js 安装教程“ 编辑文章内容如下： 123456789101112131415161718192021222324252627282930---title: Node.js 的安装教程 &#x2F;&#x2F; 文章标题comments: true &#x2F;&#x2F; 是否开启评论date: 2020-06-22 11:45:29 &#x2F;&#x2F; 文章日期categories: &#39;教程&#39; &#x2F;&#x2F; 文章分类tags: [&#39;Node.js&#39;, &#39;npm&#39;] &#x2F;&#x2F; 文章标签img: https:&#x2F;&#x2F;nodejs.org&#x2F;static&#x2F;images&#x2F;logos&#x2F;nodejs-new-pantone-white.svg &#x2F;&#x2F; 封面---## 下载官网下载 | 镜像下载---## 安装双击下一步安装---## 测试cmd---## 参考[官网]() 重新启动后，访问 教程 页面可以看到新建的文章 五、网站配置修改博客图标：在 snippet 主题下，修改 souce 目录下的 favicon.ico 图标为自己的图标。 修改博客标题及博客语言：修改博客配置文件 _config.yml 中的 Site 为： 12345678# Sitetitle: Kdockesubtitle: &#39;&#39;description: &#39;&#39;keywords:author: Kdockelanguage: zh-CNtimezone: &#39;&#39; 修改博客头像： 修改博客主题下 snippet\\source\\img\\avatar.jpg 头像为自己的头像。 修改网站宣传语： 修改博客主题下的 _config.yml 配置文件中的 branding 项为： 12## 网站宣传语branding: 生命在于折腾 修改博客 head-img 图片：修改博客主题下 snippet\\source\\img\\hea-img.jpg 图片为自己的图片，并将其链接指向自己的博客，修改 博客主题 下的配置文件 _config.yml 的 Carousel 项： 1234## Carouselcarousel: img: &#39;.&#x2F;img&#x2F;head-img.jpg&#39; url: &#39;https:&#x2F;&#x2F;kdocke.github.io&#x2F;&#39; 六、创建 about 页面在 Hexo 博客所在主目录，执行 hexo new page about : 此时会在 souce 文件夹下创建 about 文件夹，并且里面已经新建好了 index.md 文件。 新增 关于 的菜单选项，修改博客主题目录下 _config.yml 文件中的 menu 项，增加： 123- page: 关于 url: &#x2F;about&#x2F; icon: 修改 index.md： 1234567891011---title: 关于博主date: 2020-07-13 11:15:50关于我---## 关于我生命在于折腾## 联系我博主 Github 地址：https:&#x2F;&#x2F;github.com&#x2F;Kdocke联系邮箱：kdocked@163.com 重启 hexo 即可。 七、搜索配置如果要使用本地站点搜索，必须安装插件hexo-generator-json-content来创建本地搜索json文件 123npm i hexo-generator-json-content@2.2.0 -S或cnpm install --save hexo-generator-json-content@2.2.0 然后修改主题配置_config.yml文件下jsonContent相关参数。 12345678910## 搜索jsonContent: searchLocal: true &#x2F;&#x2F; 是否启用本地搜索 searchGoogle: false &#x2F;&#x2F;是否启用谷歌搜索 posts: title: true text: true content: true categories: false tags: false 八、评论配置 使用 Valine—— 一款极简的无后端评论系统 作为评论系统。 1.获取 APP ID 和 APP KEY 点击登录或注册Leancloud，注册需要实名; 创建应用 获取 APP ID 和 APP KEY: 刚刚创建的应用 &gt; 设置 &gt; 应用 KEY 2.编辑博客主题的配置文件 _config.yml 的 Valine评论项 1234567891011## Valine评论valine: enable: true appId: 自己的APP ID appKey: 自己的APP KEY placeholder: 说点什么吧 notify: false verify: false avatar: wavatar meta: nick,mail pageSize: 10 配置中 avatar（头像） 默认为 mm，可以更改，有以下选项： 参数 备注 空字符串 ‘’ Gravatar 官方图形 mm 神秘人 (一个灰白头像) identicon 抽象几何图形 (根据邮箱或昵称生成) monsterid 小怪物 wavatar 用不同面孔和背景组合生成的头像 (根据邮箱或昵称生成) retro 八位像素复古头像 (根据邮箱或昵称生成)","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Snippet","slug":"Snippet","permalink":"http://yoursite.com/tags/Snippet/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}]},{"title":"使用 Hexo 搭建个人博客","slug":"使用Hexo搭建个人博客","date":"2020-06-19T08:29:29.000Z","updated":"2020-07-14T12:32:06.219Z","comments":true,"path":"2020/06/19/使用Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/06/19/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"一、安装 Git参考：Git 安装教程 二、安装 Node.js参考: Node.js 安装教程 三、安装 hexo使用 cnpm 安装 hexo-cli 验证 hexo 安装结果 四、本地简单使用1. 建立 FirstBlog 文件夹，并进入 2. 在 FirstBlog 文件夹中初始化博客 3. 安装后的文件 4. 启动博客 hexo s 5. 创建博文 hexo n 6. 编辑并保存第一篇博文 7. 清理 hexo clean 8. 重新生成 hexo g 9. 重新启动博客 hexo s 五、将博客部署到 GitHub1. 进入个人 GitHub，创建一个新仓库，注意仓库名的命名规则，需要自己的账号名 + github.io，后面需要用此仓库名来访问部署好的博客 2. 安装 git 部署插件 cnpm install --save hexo-deployer-git 3. 修改 Blog 目录下的 _config.yml 文件，将文件末尾的 deploy 项修改为以下内容 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/Kdocke/Kdocke.github.io.git # 刚刚新建的仓库地址 branch: master 4. 开始部署 hexo d，中途会要求输入 github 的账号和密码，正常输入就可以 5. 使用之前的仓库名访问部署好的博客网站 六、更换主题主题地址：hexo-theme-yilia 1. 安装 yilia 主题 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 2. 修改 Blog 目录下的 _config.yml 文件，更改 theme 部分为以下内容: 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 3. 重新清理生成，hexo clean and hexo g 4. 本地启动查看 hexo s 5. 将博客推到 github，hexo d 6. 访问 七、参考 CodeSheep程序羊 Youtube 视频教程","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}]},{"title":"Node.js 的安装教程","slug":"Node-js的安装教程","date":"2020-06-19T07:30:30.000Z","updated":"2020-07-14T11:41:00.094Z","comments":true,"path":"2020/06/19/Node-js的安装教程/","link":"","permalink":"http://yoursite.com/2020/06/19/Node-js%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、下载官网下载：Node.js 一般选择下载左侧的长期支持版本 二、安装1. 双击安装包 2. Next 3. 同意协议 4. 选择安装位置，建议安装在 D 盘 5. 这里运行环境、npm 包管理器、在线文档快捷方式、添加到环境变量四项全部安装 6. 不用勾选，直接 Next 7. install 8. 等待安装完成，安装完成后会有两个组件 Node.js 本身 npm 包管理器 三、验证打开 cmd，分别输入 node --version 和 npm --version, 如果正确输出版本号，证明安装成功 四、设置依赖包安装路径1. 在 nodejs 安装目录下创建 node_global 以及 node_cache 文件夹 2. 在 nodejs\\node_modules\\npm 设置 npmrc文件，使用文本文档打开修改里面的配置 12prefix&#x3D;D:\\bProgramSoftware\\nodejs\\node_globalcache&#x3D;D:\\bProgramSoftware\\nodejs\\node_cache 3. 设置环境变量，在 “系统变量” 中新建 变量名为 NODE_PATH， 变量值为 D:\\bProgramSoftware\\nodejs（变量值是自己 node 安装的根目录） 之后在 “系统变量” 的 path 中新建两个变量 %NODE_PATH%\\node_modules 和 %NODE_PATH%\\node_global 五、安装淘宝镜像1npm install -g cnpm --registry=https://registry.npm.taobao.org","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}]},{"title":"Git 的安装教程","slug":"Git的安装教程","date":"2020-06-19T06:52:52.000Z","updated":"2020-07-14T11:33:44.464Z","comments":true,"path":"2020/06/19/Git的安装教程/","link":"","permalink":"http://yoursite.com/2020/06/19/Git%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、下载网址：git 官网 或 淘宝镜像 二、安装1. 双击安装程序，点击 Next 2. 更改安装路径，建议 D 盘，点击 Next 3. 选择安装组件，可以直接 Next 4. 直接 Next，创建开始菜单 5. 选择编辑方式，默认使用 Vim，点击 Next 6. 使用方式，三种，默认选择第二种 7. 选择 OpenSSL 远程连接方式，Next 8. 配置换行格式，默认，Next 9. 配置终端，默认，Next 10. 默认，Next 11. 默认配置，Next 12. 安装 13. 安装完成 三、验证命令行输入 git --version","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}]}]}